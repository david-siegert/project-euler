// The following problem is taken from Project Euler. Solution is mine.

// The sequence of triangle numbers is generated by adding the natural numbers. 
// So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
// 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
// Let us list the factors of the first seven triangle numbers:
//      1: 1
//      3: 1,3
//      6: 1,2,3,6
//     10: 1,2,5,10
//     15: 1,3,5,15
//     21: 1,3,7,21
//     28: 1,2,4,7,14,28
// We can see that 28 is the first triangle number to have over five divisors.

// What is the value of the first triangle number to have over five hundred divisors?

import factor from './factor.js';

// trivial solution takes to loong to check all divisions
// algo: get prime factors -> calculate possible permutations > 500 ?

var currTriangl = 0;
var counter = 0;
let factors = [];

while (true) {

    counter++;
    currTriangl += counter;

    if (currTriangl > 500) {

        factors = factor.primeFactorsAsc(currTriangl);

        var divisors = DivisorPermutations(factors);

        if (divisors > 500) {

            console.log(currTriangl);
            break;
        }
    }
}

//console.log(DivisorPermutations([2,2,2,2,7,13,13,37]));

function UniqueFactorArrays(inputArray) {

    // [2,2,2,3,3,5,5,5,5,7,11,13,13] -> [2,3,5,7,11,13], [2,3,5,13], [2,5], [5] 

    var result = [[]];

    let currValue = 0;
    let lastValue = 0;
    let index = 0;

    while (inputArray.length > 0) {

        if (index > inputArray.length - 1) {
            index = 0;
            lastValue = 0;
            result.push([]);
        }

        currValue = inputArray[index];

        if (lastValue != currValue) {

            // delete form input
            lastValue = inputArray.splice(index, 1);

            // push to result
            result[result.length - 1].push(lastValue[0]);
        }
        else {
            index++;
        }
    }

    return result;
}
function DivisorPermutations(primeFactors) {

    // combinatorics to calc the possible divisors

    var result = 1;
    for (let index = 0; index < primeFactors.length; index++) {

        const factor = primeFactors[index];

        // speeder
        var count = 1;
        while (factor == primeFactors[index + 1]) {
            index++;
            count++;
        }
        count++; // option where this factor isnt included 

        result = result * count;
    }

    return result
}